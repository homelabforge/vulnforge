"""Vulnerability repository for centralized vulnerability queries."""

from sqlalchemy import Integer, func, join, select
from sqlalchemy.ext.asyncio import AsyncSession

from app.models import Container, Scan, Vulnerability


class VulnerabilityRepository:
    """Repository for Vulnerability model with consistent filtering."""

    def __init__(self, db: AsyncSession):
        """
        Initialize the repository.

        Args:
            db: AsyncSession database session
        """
        self.db = db

    def _get_base_query(self, exclude_false_positives: bool = True):
        """
        Base query for vulnerabilities.

        Args:
            exclude_false_positives: Whether to exclude false positives

        Returns:
            Base query
        """
        query = select(Vulnerability)
        if exclude_false_positives:
            query = query.where(Vulnerability.status != "false_positive")
        return query

    async def count_total(self, exclude_false_positives: bool = True) -> int:
        """
        Count total vulnerabilities.

        Args:
            exclude_false_positives: Whether to exclude false positives

        Returns:
            Total count of vulnerabilities
        """
        query = select(func.count(Vulnerability.id))
        if exclude_false_positives:
            query = query.where(Vulnerability.status != "false_positive")

        result = await self.db.execute(query)
        return result.scalar_one()

    async def count_by_severity(self, severity: str, exclude_false_positives: bool = True) -> int:
        """
        Count vulnerabilities by severity level.

        Args:
            severity: Severity level (CRITICAL, HIGH, MEDIUM, LOW)
            exclude_false_positives: Whether to exclude false positives

        Returns:
            Count of vulnerabilities with the specified severity
        """
        query = select(func.count(Vulnerability.id)).where(
            Vulnerability.severity == severity.upper()
        )
        if exclude_false_positives:
            query = query.where(Vulnerability.status != "false_positive")

        result = await self.db.execute(query)
        return result.scalar_one()

    async def count_fixable(self, exclude_false_positives: bool = True) -> int:
        """
        Count fixable vulnerabilities.

        Args:
            exclude_false_positives: Whether to exclude false positives

        Returns:
            Count of fixable vulnerabilities
        """
        query = select(func.count(Vulnerability.id)).where(Vulnerability.is_fixable)
        if exclude_false_positives:
            query = query.where(Vulnerability.status != "false_positive")

        result = await self.db.execute(query)
        return result.scalar_one()

    async def count_kev(self, exclude_false_positives: bool = True) -> int:
        """
        Count Known Exploited Vulnerabilities (KEV).

        Args:
            exclude_false_positives: Whether to exclude false positives

        Returns:
            Count of KEV vulnerabilities
        """
        query = select(func.count(Vulnerability.id)).where(Vulnerability.is_kev)
        if exclude_false_positives:
            query = query.where(Vulnerability.status != "false_positive")

        result = await self.db.execute(query)
        return result.scalar_one()

    async def count_by_container(
        self, container_id: int, exclude_false_positives: bool = True
    ) -> int:
        """
        Count vulnerabilities for a specific container.

        Args:
            container_id: Container ID
            exclude_false_positives: Whether to exclude false positives

        Returns:
            Count of vulnerabilities for the container
        """
        query = (
            select(func.count(Vulnerability.id))
            .join(Scan, Vulnerability.scan_id == Scan.id)
            .where(Scan.container_id == container_id)
        )
        if exclude_false_positives:
            query = query.where(Vulnerability.status != "false_positive")

        result = await self.db.execute(query)
        return result.scalar_one()

    async def get_all(
        self,
        severity: str | None = None,
        fixable_only: bool = False,
        kev_only: bool = False,
        status: str | None = None,
        container_id: int | None = None,
        limit: int = 100,
        offset: int = 0,
        exclude_false_positives: bool = True,
    ) -> tuple[list[dict], int]:
        """
        Get all vulnerabilities with filters and pagination.

        Args:
            severity: Optional severity filter
            fixable_only: Filter for fixable vulnerabilities only
            kev_only: Filter for KEV vulnerabilities only
            status: Optional status filter
            container_id: Optional container ID filter
            limit: Maximum number of results
            offset: Pagination offset
            exclude_false_positives: Whether to exclude false positives

        Returns:
            Tuple of (list of vulnerability dicts, total count)
        """
        # Build base query for data
        data_query = (
            select(
                Vulnerability.id,
                Vulnerability.cve_id,
                Container.name.label("container_name"),
                Container.id.label("container_id"),
                Vulnerability.package_name,
                Vulnerability.severity,
                Vulnerability.cvss_score,
                Vulnerability.installed_version,
                Vulnerability.fixed_version,
                Vulnerability.is_fixable,
                Vulnerability.scanner,
                Vulnerability.confidence,
                Vulnerability.status,
                Vulnerability.title,
                Vulnerability.is_kev,
                Vulnerability.kev_added_date,
                Vulnerability.kev_due_date,
            )
            .select_from(join(Vulnerability, Scan, Vulnerability.scan_id == Scan.id))
            .join(Container, Scan.container_id == Container.id)
        )

        # Build count query
        count_query = (
            select(func.count(Vulnerability.id))
            .select_from(join(Vulnerability, Scan, Vulnerability.scan_id == Scan.id))
            .join(Container, Scan.container_id == Container.id)
        )

        # Apply filters to both queries
        if exclude_false_positives:
            data_query = data_query.where(Vulnerability.status != "false_positive")
            count_query = count_query.where(Vulnerability.status != "false_positive")

        if severity:
            data_query = data_query.where(Vulnerability.severity == severity.upper())
            count_query = count_query.where(Vulnerability.severity == severity.upper())

        if fixable_only:
            data_query = data_query.where(Vulnerability.is_fixable)
            count_query = count_query.where(Vulnerability.is_fixable)

        if kev_only:
            data_query = data_query.where(Vulnerability.is_kev)
            count_query = count_query.where(Vulnerability.is_kev)

        if status:
            data_query = data_query.where(Vulnerability.status == status)
            count_query = count_query.where(Vulnerability.status == status)

        if container_id:
            # Get the latest scan ID for this container
            latest_scan_subquery = (
                select(Scan.id)
                .where(Scan.container_id == container_id)
                .order_by(Scan.scan_date.desc())
                .limit(1)
                .scalar_subquery()
            )
            data_query = data_query.where(Scan.id == latest_scan_subquery)
            count_query = count_query.where(Scan.id == latest_scan_subquery)

        # Get total count
        count_result = await self.db.execute(count_query)
        total = count_result.scalar() or 0

        # Order by severity and CVSS score with pagination
        data_query = (
            data_query.order_by(Vulnerability.severity.desc(), Vulnerability.cvss_score.desc())
            .limit(limit)
            .offset(offset)
        )

        result = await self.db.execute(data_query)
        rows = result.fetchall()

        vulnerabilities = [
            {
                "id": row[0],
                "cve_id": row[1],
                "container_name": row[2],
                "container_id": row[3],
                "package_name": row[4],
                "severity": row[5],
                "cvss_score": row[6],
                "installed_version": row[7],
                "fixed_version": row[8],
                "is_fixable": row[9],
                "scanner": row[10],
                "confidence": row[11],
                "status": row[12],
                "title": row[13],
                "is_kev": row[14],
                "kev_added_date": row[15],
                "kev_due_date": row[16],
            }
            for row in rows
        ]

        return vulnerabilities, total

    async def get_by_id(self, vuln_id: int) -> Vulnerability | None:
        """
        Get a specific vulnerability by ID.

        Args:
            vuln_id: Vulnerability ID

        Returns:
            Vulnerability if found, None otherwise
        """
        result = await self.db.execute(select(Vulnerability).where(Vulnerability.id == vuln_id))
        return result.scalar_one_or_none()

    async def get_remediation_groups(
        self, container_id: int | None = None, exclude_false_positives: bool = True
    ) -> list[dict]:
        """
        Get remediation groups - packages that can be updated to fix multiple CVEs.

        Args:
            container_id: Optional container ID filter
            exclude_false_positives: Whether to exclude false positives

        Returns:
            List of remediation group dicts
        """
        # Base query - group by package and fixed version for fixable CVEs
        query = (
            select(
                Vulnerability.package_name,
                Vulnerability.installed_version,
                Vulnerability.fixed_version,
                func.count(Vulnerability.id).label("cve_count"),
                func.sum(func.cast((Vulnerability.severity == "CRITICAL"), Integer)).label(
                    "critical_count"
                ),
                func.sum(func.cast((Vulnerability.severity == "HIGH"), Integer)).label(
                    "high_count"
                ),
                func.sum(func.cast((Vulnerability.severity == "MEDIUM"), Integer)).label(
                    "medium_count"
                ),
                func.sum(func.cast((Vulnerability.severity == "LOW"), Integer)).label("low_count"),
            )
            .where(Vulnerability.is_fixable)
            .where(Vulnerability.fixed_version.isnot(None))
        )

        if exclude_false_positives:
            query = query.where(Vulnerability.status != "false_positive")

        # If container_id is specified, filter by container
        if container_id:
            query = query.select_from(
                join(Vulnerability, Scan, Vulnerability.scan_id == Scan.id)
            ).where(Scan.container_id == container_id)

        query = query.group_by(
            Vulnerability.package_name,
            Vulnerability.installed_version,
            Vulnerability.fixed_version,
        ).order_by(func.count(Vulnerability.id).desc())

        result = await self.db.execute(query)
        rows = result.fetchall()

        return [
            {
                "package_name": row[0],
                "installed_version": row[1],
                "fixed_version": row[2],
                "cve_count": row[3],
                "critical_count": row[4] or 0,
                "high_count": row[5] or 0,
                "medium_count": row[6] or 0,
                "low_count": row[7] or 0,
            }
            for row in rows
        ]

    async def get_for_export(
        self,
        severity: str | None = None,
        fixable_only: bool = False,
        status: str | None = None,
        exclude_false_positives: bool = True,
    ) -> list[dict]:
        """
        Get vulnerabilities for export.

        Args:
            severity: Optional severity filter
            fixable_only: Filter for fixable vulnerabilities only
            status: Optional status filter
            exclude_false_positives: Whether to exclude false positives

        Returns:
            List of vulnerability dicts
        """
        query = (
            select(
                Vulnerability.cve_id,
                Container.name.label("container_name"),
                Vulnerability.package_name,
                Vulnerability.severity,
                Vulnerability.cvss_score,
                Vulnerability.installed_version,
                Vulnerability.fixed_version,
                Vulnerability.is_fixable,
                Vulnerability.status,
                Vulnerability.title,
            )
            .select_from(join(Vulnerability, Scan, Vulnerability.scan_id == Scan.id))
            .join(Container, Scan.container_id == Container.id)
        )

        # Apply filters
        if exclude_false_positives:
            query = query.where(Vulnerability.status != "false_positive")

        if severity:
            query = query.where(Vulnerability.severity == severity.upper())

        if fixable_only:
            query = query.where(Vulnerability.is_fixable)

        if status:
            query = query.where(Vulnerability.status == status)

        query = query.order_by(Vulnerability.severity.desc(), Vulnerability.cvss_score.desc())

        result = await self.db.execute(query)
        rows = result.fetchall()

        return [
            {
                "cve_id": row[0],
                "container": row[1],
                "package": row[2],
                "severity": row[3],
                "cvss_score": row[4],
                "installed_version": row[5],
                "fixed_version": row[6],
                "is_fixable": row[7],
                "status": row[8],
                "title": row[9],
            }
            for row in rows
        ]

    async def update_status(
        self, vuln_id: int, status: str, notes: str | None = None
    ) -> Vulnerability | None:
        """
        Update a vulnerability's status and notes.

        Args:
            vuln_id: Vulnerability ID
            status: New status value
            notes: Optional notes

        Returns:
            Updated vulnerability if found, None otherwise
        """
        result = await self.db.execute(select(Vulnerability).where(Vulnerability.id == vuln_id))
        vuln = result.scalar_one_or_none()

        if not vuln:
            return None

        if status is not None:
            vuln.status = status
        if notes is not None:
            vuln.notes = notes

        await self.db.commit()
        await self.db.refresh(vuln)

        return vuln

    async def bulk_update_status(
        self, vuln_ids: list[int], status: str, notes: str | None = None
    ) -> int:
        """
        Bulk update multiple vulnerabilities' status and notes.

        Args:
            vuln_ids: List of vulnerability IDs
            status: New status value
            notes: Optional notes

        Returns:
            Number of vulnerabilities updated
        """
        result = await self.db.execute(select(Vulnerability).where(Vulnerability.id.in_(vuln_ids)))
        vulns = result.scalars().all()

        updated_count = 0
        for vuln in vulns:
            if status is not None:
                vuln.status = status
            if notes is not None:
                vuln.notes = notes
            updated_count += 1

        await self.db.commit()
        return updated_count
